Broadly, it can be classified into two parts :
Part 1 : 
•	Pre-release bugs
o	No use of bugzila
o	We use the github api to get the sha values 
o	We then use the second github api to get the files associated
o	We calculate the entropy
o	Final output will be each file with the corresponding entropy values
Part 2:
•	Post release bugs 
o	We use bugzila
o	Same procedure
o	Final output will be each file corresponding to the number of bugs
Part 1 : Detailed
•	We use the github api 1 to get all the commit values from 2.1 release date to the version 3.0 date
•	We use python to send a request 
(r = requests.get('https://api.github.com/user', auth=('user', 'pass'))
Refer : http://docs.python-requests.org/en/latest/
Note : We also the pass the since and until date , that is the 2.1 and 3.0 dates.
•	Using this ‘r’ object we get the Jason object, assign it to some variable.
•	Using this Json object, we then use the meta structure to get the sha values and we store it in text file. ( Json is a dict object)
•	In the next script , we use these sha values and get the corresponding timestamp for the commit using the second github api (refer the github documentation under the commit section)
•	Now for each of the sha values , we go and fetch the Json object and store the dictionary object as a file.  ( Note: This we can store as a string object in the local system, which can be later fetched into python as a string and converted into a Jason object once again , reason for doing this, repeating experiment won’t require net connection. We would have all the commit objects )
•	Now, for each sha value, we look into its corresponding Json(dictionary object) and get the timestamp and list of files changed.  
•	Using  the list of files, we maintain an a linked list for each of the file, keeping track of all the time stamps it was changed on. Eg : File 1 -> 2-2-14, 7-3-14 , and so on.
•	Finally, we store this above data structure into a text file ( so that we can perform vertical of horizontal entropy accordingly)
•	We calculate the entropy based on the time stamps and periods we divided into.
•	This brings end of part 1 . We have gotten the output , i.e, the entropy for each file
•	Note: For each period, we can calculate the entropy, H value and we get a HCM for each file. That is the desired output. ( Refer Hasan entropy paper)
Part 2 : Detailed 
•	For this part, we will be using bugzila.
•	Using bugzila on versions 3.0 ( Post release ) , we get list of all IDs of the bugs reported (Note : we use time period of 1 year on reporting and 2 years on the commit)
•	So output of this : A file containing a list of IDs ad the timestamps
•	Next phase is, we again use the github api 1 and fetch all the commits for a period of 2 years , starting from 3.0 release date to 2 years from then. 
•	On this Jason object , we discard all those which are not required (ie, do not have a bug id in their description message, use regex for this ) and create a file containing  just sha values and the bug IDs , that is ID for the corresponding reported bug in bugzila.
•	Now, we use the file generated by bugzila and the file generated in the above point to get the number of bugs in each file in the post release session.
•	We take up an ID in the bugzilla file generated and check corresponding sha value, use the github api 2 to get the corresponding report , look up at the files changed and increment counter for each of the files.
•	Final output will thus be a text file containing each file and the number of bugs present
•	Part 2 ends here.
Finally, we have two files, output from part 1 and part 2
Part 1 : Entropy values for each of the files
Part 2 : Number of bugs for each of the files
On this, we can divide the date into 66- 33 split as training and testing data and perform one of the machine learning algorithms.
We can either predict the number of bugs  , or predict if the file is buggy or non buggy.
For checking buggy or non buggy, we can use an algorithm like Naïve Bayes.
For predicting number of bugs, we can use linear regression.
Thus, we get the results, that is the precision , recall values on which we decide how good the parameter of choosing entropy as a characteristic for bug detection is .

Notes: 
•	For the second api, the sha values are not passed as parameters but are passed along with the URL
This is done by appending the sha value at the end of the URL . eg  XXX / ‘Sha value’
One of the better ways to do it is to use XXX/{} . format(Sha value) which puts the sha value directly into the {} .
•	1 year for reports and 2 years for commit:
By doing this, we are considering only reports that have been made within one year of the release of the version 3.0  We are additionally giving each of the report of bugs to be fixed within one year of release. In the worst case, a bug could be reported at the end of the first year after the release of the version 3.0 , in which case , giving one year of time for it to be fixed could mean 2 years from the release of version 3.0 . Thus we fetch 2 years of commits from 3.0 release date on github api 1. ( and 1 year in bugzila for the reports)


3.0
Fri, 25 Jun 2004 -- 12:08 (-0400)
2.1
Thu, 27 Mar 2003 -- 21:30 (-0500)
Release dates 
•	3.0 : 2004-06-25 12:08:00 -0400
•	2.1:  2003-03-27 21:30:00 -0500

find -L | grep -i '.java$' to get all file names along with the path as well.
	           
